function [alpha, beta1, beta2] = designDLC(rstar, peak, threshold, epsilon,tolerance)
% function [alpha, beta1, beta2] = designDLC(rstar, peak, threshold,
epsilon, tolerance)
%
% Finds alpha, beta1 and beta2 for double limit cycle oscillator w/o input
% specified by limit cycle amplitude (rstar), the depth of local min
% (threshold), the height of local max (peak) and epsilon. threshold must
% be a positive value.

ra = rstar;
rdotb = peak;
rdotc = -threshold;
if nargin < 5
  tolerance = power(10,-2);
  disp(['Default tolerance = ' num2str(tolerance)])
end
if rstar < 0 || rstar > 1/sqrt(epsilon)
  error('Invalid value of rstar')
end
if threshold <= 0
  error('threshold (depth of trough) must be positive')
end
if ~isnan(rstar) && peak < 0
  error('peak must be positive')
end
if isnan(rstar) && peak < -threshold
  error('peak must be higher than trough')
end

% Initial range of a, b1, b2
amin = -500; amax = 0;
b1min = 0; b1max = 500;
b2min = -500; b2max = 0;
npt = 101; % # of points in each gradient
mindev = tolerance + 1;


while mindev > tolerance

  a = linspace(amin,amax,npt);
  b1 = linspace(b1min,b1max,npt);
  b2 = linspace(b2min,b2max,npt);
  [A,B1,B2] = meshgrid(a,b1,b2);

  % r at local max
  Rb = sqrt(-(power(B1 - B2,-1).*power(epsilon,-2).*...
    (4.*epsilon.*(-6.*B1 + 5.*B2 + A.*epsilon) - ...
    2.*1i.*power(2,1./3).*(1i + power(3,0.5)).*power(epsilon,2).*...
    (-33.*B1.*B2 + 6.*A.*B1.*epsilon - 8.*A.*B2.*epsilon + ...
    9.*power(B1,2) + 25.*power(B2,2) + power(A,2).*power(epsilon,2)).*...
    power(-27.*(7.*B2 + 2.*A.*epsilon).*power(B1,2).*power(epsilon,3) - ...
    54.*power(B1,3).*power(epsilon,3) - 250.*power(B2,3).*power(epsilon,3) +
...
    9.*B1.*(19.*A.*B2.*epsilon + 55.*power(B2,2) - ...
    2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
    123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
    power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) +
9.*power(3,0.5).*...
    power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
    (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
    power(B1,2) + 216.*power(B1,3) + A.*epsilon.*...
    (-97.*A.*B2.*epsilon + 500.*power(B2,2) + 8.*power(A,2).*...
    power(epsilon,2))).*power(epsilon,6),0.5),-1./3) + power(2,2./3).*...
    (1 + 1i.*power(3,0.5)).*power(-27.*(7.*B2 + 2.*A.*epsilon).*...
    power(B1,2).*power(epsilon,3) - 54.*power(B1,3).*power(epsilon,3) - ...
    250.*power(B2,3).*power(epsilon,3) + 9.*B1.*(19.*A.*B2.*epsilon + ...
    55.*power(B2,2) - 2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) -
...
    123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
    power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) +
9.*power(3,0.5).*...
    power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
    (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
    power(B1,2) + 216.*power(B1,3) + A.*epsilon.*...
    (-97.*A.*B2.*epsilon + 500.*power(B2,2) + 8.*power(A,2).*...
    power(epsilon,2))).*power(epsilon,6),0.5),1./3)))./36);

  % r at local min
  Rc = sqrt((power(B1 - B2,-1).*power(epsilon,-2).*...
    (-4.*epsilon.*(-6.*B1 + 5.*B2 + A.*epsilon) - ...
    2.*1i.*power(2,1./3).*(-1i + power(3,0.5)).*power(epsilon,2).*...
    (-33.*B1.*B2 + 6.*A.*B1.*epsilon - 8.*A.*B2.*epsilon + ...
    9.*power(B1,2) + 25.*power(B2,2) + power(A,2).*power(epsilon,2)).*...
    power(-27.*(7.*B2 + 2.*A.*epsilon).*power(B1,2).*power(epsilon,3) - ...
    54.*power(B1,3).*power(epsilon,3) - 250.*power(B2,3).*power(epsilon,3) +
...
    9.*B1.*(19.*A.*B2.*epsilon + 55.*power(B2,2) - ...
    2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
    123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
    power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) +
9.*power(3,0.5).*...
    power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
    (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*power(B1,2)
+ ...
    216.*power(B1,3) + A.*epsilon.*(-97.*A.*B2.*epsilon + 500.*power(B2,2) +
...
    8.*power(A,2).*power(epsilon,2))).*power(epsilon,6),0.5),-1./3) +...
    1i.*power(2,2./3).*(1i + power(3,0.5)).*power(-27.*(7.*B2 +
2.*A.*epsilon).*...
    power(B1,2).*power(epsilon,3) - 54.*power(B1,3).*power(epsilon,3) - ...
    250.*power(B2,3).*power(epsilon,3) + 9.*B1.*(19.*A.*B2.*epsilon + ...
    55.*power(B2,2) - 2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) -
...
    123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
    power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) +
9.*power(3,0.5).*...
    power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
    (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
    power(B1,2) + 216.*power(B1,3) + A.*epsilon.*(-97.*A.*B2.*epsilon + ...
    500.*power(B2,2) + 8.*power(A,2).*power(epsilon,2))).*...
    power(epsilon,6),0.5),1./3)))./36);

  Rb(find(abs(imag(Rb)) > eps('single'))) == NaN; Rb = real(Rb);
  Rc(find(abs(imag(Rc)) > eps('single'))) == NaN; Rc = real(Rc);

  EQa = A*ra + B1*ra^3 + epsilon*B2*ra^5/(1-epsilon*ra^2);
  EQb = A.*Rb + B1.*Rb.^3 + epsilon*B2.*Rb.^5./(1-epsilon*Rb.^2) - rdotb;
  EQc = A.*Rc + B1.*Rc.^3 + epsilon*B2.*Rc.^5./(1-epsilon*Rc.^2) - rdotc;

  if isnan(ra) % if rstar is NaN
    DEV = abs(EQb) + abs(EQc);
  else
    DEV = abs(EQa) + abs(EQb) + abs(EQc);
  end
  mindev = min(min(min(DEV)));
  ind = find(DEV == mindev);

  if mindev > tolerance; string = '>';
  elseif mindev == tolerance; string = '=';
  else string = '<';
  end
  disp(['min deviation = ' num2str(mindev) '(' string ' tolerance)'])

  % Range of a, b1, b2 for the next loop
  amin = A(ind) - range(a)/(npt-1);
  amax = A(ind) + range(a)/(npt-1);
  b1min = B1(ind) - range(b1)/(npt-1);
  b1max = B1(ind) + range(b1)/(npt-1);
  b2min = B2(ind) - range(b2)/(npt-1);
  b2max = B1(ind) + range(b2)/(npt-1);

end

alpha = A(ind);
beta1 = B1(ind);
beta2 = B2(ind);



