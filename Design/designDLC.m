%% designDLC
%  [alpha, beta1, beta2] = designDLC(rStar, localMax, localMin, epsilon, tolerance)
%
%  Finds alpha, beta1 and beta2 for a double limit cycle oscillator whose
%  autonomous amplitude vector field is defined by three given points
%  (rStar, localMax, localMin) and epsilon.
%
%  Input arguments:
%  rStar            Stable nonzero fixed point in autonomous amplitude
%                   vector field. Put NaN if there is none.
%  localMax         Local maximum in vector field
%  localMin         Local minimum in vector field
%  epsilon          epsilon parameter
%
%  Optional input:
%  tolerance        Tolerance for mismatch (.01 by default)
%
%  Output:
%  alpha, beta1, beta2
%                   Oscillator parameters
%
%  Example:
%    [a, b1, b2] = designDLC(.8, .3, -.2, 1);
%

%%
function [alpha, beta1, beta2] = designDLC(rStar, localMax, localMin, epsilon, tolerance)

if nargin < 5
    tolerance = power(10,-2);
    disp(['Default tolerance = ' num2str(tolerance)])
end
if rStar < 0 || rStar > 1/sqrt(epsilon)
    error('Invalid value of rstar: must be a positive number smaller than 1/sqrt(epsilon)')
end
if localMin >= 0
    error('localMin must be negative')
end
if ~isnan(rStar) && localMax < 0
    error('peak must be positive')
end
if isnan(rStar) && localMax < localMin
    error('locaMax must be higher than localMin')
end

% Initial range of a, b1, b2
amin  = -500;   amax  = 0;
b1min = 0;      b1max = 500;
b2min = -500;   b2max = 0;
N = 101; % # of points in each gradient
minDev = tolerance + 1;
disp('Searching...')

while minDev > tolerance
    
    a = linspace(amin, amax, N);
    b1 = linspace(b1min, b1max, N);
    b2 = linspace(b2min, b2max, N);
    [A, B1, B2] = meshgrid(a, b1, b2);
    
    % r at local max
    Rb = sqrt(-(power(B1 - B2,-1).*power(epsilon,-2).*...
        (4.*epsilon.*(-6.*B1 + 5.*B2 + A.*epsilon) - ...
        2.*1i.*power(2,1./3).*(1i + power(3,0.5)).*power(epsilon,2).*...
        (-33.*B1.*B2 + 6.*A.*B1.*epsilon - 8.*A.*B2.*epsilon + ...
        9.*power(B1,2) + 25.*power(B2,2) + power(A,2).*power(epsilon,2)).*...
        power(-27.*(7.*B2 + 2.*A.*epsilon).*power(B1,2).*power(epsilon,3) - ...
        54.*power(B1,3).*power(epsilon,3) - 250.*power(B2,3).*power(epsilon,3) + ...
        9.*B1.*(19.*A.*B2.*epsilon + 55.*power(B2,2) - ...
        2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
        123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
        power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) + 9.*power(3,0.5).*...
        power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
        (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
        power(B1,2) + 216.*power(B1,3) + A.*epsilon.*...
        (-97.*A.*B2.*epsilon + 500.*power(B2,2) + 8.*power(A,2).*...
        power(epsilon,2))).*power(epsilon,6),0.5),-1./3) + power(2,2./3).*...
        (1 + 1i.*power(3,0.5)).*power(-27.*(7.*B2 + 2.*A.*epsilon).*...
        power(B1,2).*power(epsilon,3) - 54.*power(B1,3).*power(epsilon,3) - ...
        250.*power(B2,3).*power(epsilon,3) + 9.*B1.*(19.*A.*B2.*epsilon + ...
        55.*power(B2,2) - 2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
        123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
        power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) + 9.*power(3,0.5).*...
        power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
        (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
        power(B1,2) + 216.*power(B1,3) + A.*epsilon.*...
        (-97.*A.*B2.*epsilon + 500.*power(B2,2) + 8.*power(A,2).*...
        power(epsilon,2))).*power(epsilon,6),0.5),1./3)))./36);
    
    % r at local min
    Rc = sqrt((power(B1 - B2,-1).*power(epsilon,-2).*...
        (-4.*epsilon.*(-6.*B1 + 5.*B2 + A.*epsilon) - ...
        2.*1i.*power(2,1./3).*(-1i + power(3,0.5)).*power(epsilon,2).*...
        (-33.*B1.*B2 + 6.*A.*B1.*epsilon - 8.*A.*B2.*epsilon + ...
        9.*power(B1,2) + 25.*power(B2,2) + power(A,2).*power(epsilon,2)).*...
        power(-27.*(7.*B2 + 2.*A.*epsilon).*power(B1,2).*power(epsilon,3) - ...
        54.*power(B1,3).*power(epsilon,3) - 250.*power(B2,3).*power(epsilon,3) + ...
        9.*B1.*(19.*A.*B2.*epsilon + 55.*power(B2,2) - ...
        2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
        123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
        power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) + 9.*power(3,0.5).*...
        power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
        (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*power(B1,2) + ...
        216.*power(B1,3) + A.*epsilon.*(-97.*A.*B2.*epsilon + 500.*power(B2,2) + ...
        8.*power(A,2).*power(epsilon,2))).*power(epsilon,6),0.5),-1./3) +...
        1i.*power(2,2./3).*(1i + power(3,0.5)).*power(-27.*(7.*B2 + 2.*A.*epsilon).*...
        power(B1,2).*power(epsilon,3) - 54.*power(B1,3).*power(epsilon,3) - ...
        250.*power(B2,3).*power(epsilon,3) + 9.*B1.*(19.*A.*B2.*epsilon + ...
        55.*power(B2,2) - 2.*power(A,2).*power(epsilon,2)).*power(epsilon,3) - ...
        123.*A.*power(B2,2).*power(epsilon,4) + 24.*B2.*power(A,2).*...
        power(epsilon,5) - 2.*power(A,3).*power(epsilon,6) + 9.*power(3,0.5).*...
        power(B2.*power(B1 - B2,2).*(6.*A.*B1.*epsilon.*...
        (-115.*B2 + 12.*A.*epsilon) - 9.*(25.*B2 - 24.*A.*epsilon).*...
        power(B1,2) + 216.*power(B1,3) + A.*epsilon.*(-97.*A.*B2.*epsilon + ...
        500.*power(B2,2) + 8.*power(A,2).*power(epsilon,2))).*...
        power(epsilon,6),0.5),1./3)))./36);
    
    Rb(abs(imag(Rb)) > eps('single')) = NaN; Rb = real(Rb);
    Rc(abs(imag(Rc)) > eps('single')) = NaN; Rc = real(Rc);
    
    EQa = A*rStar + B1*rStar^3 + epsilon*B2*rStar^5/(1-epsilon*rStar^2);
    EQb = A.*Rb + B1.*Rb.^3 + epsilon*B2.*Rb.^5./(1-epsilon*Rb.^2) - localMax;
    EQc = A.*Rc + B1.*Rc.^3 + epsilon*B2.*Rc.^5./(1-epsilon*Rc.^2) - localMin;
    
    if isnan(rStar) % if rstar is NaN
        DEV = abs(EQb) + abs(EQc);
    else
        DEV = abs(EQa) + abs(EQb) + abs(EQc);
    end
    [minDev, ind] = min(DEV(:));
    
    if minDev > tolerance; string = '>';
    elseif minDev == tolerance; string = '=';
    else string = '<';
    end
    disp(['alpha = ' num2str(A(ind)) ', beta1 = ' num2str(B1(ind)) ...
        ', beta2 = ' num2str(B2(ind)) ...
        ' (deviation = ' num2str(minDev) ' ' string ' tolerance)'])
    
    % Range of a, b1, b2 for the next interation
    narrowBy = .25; % narrow ranges by this factor
    amin = A(ind) - (amax-amin)*narrowBy;
    amax = min(0, A(ind) + (amax-amin)*narrowBy);
    b1min = max(0, B1(ind) - (b1max-b1min)*narrowBy);
    b1max = B1(ind) + (b1max-b1min)*narrowBy;
    b2min = B2(ind) - (b2max-b2min)*narrowBy;
    b2max = min(0, B2(ind) + (b2max-b2min)*narrowBy);
end

alpha = A(ind);
beta1 = B1(ind);
beta2 = B2(ind);
